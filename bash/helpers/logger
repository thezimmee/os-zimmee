#!/usr/bin/env bash
#
# simple logging utilities

## colors
BOLD="\033[1m"
NOBOLD="\033[21m"
DIM="\033[2m"
NODIM="\033[22m"
BLACK="\033[30m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"
END="\033[0m"

INFO="[ ${BLUE}..${END} ]"
WARNING="[ ${BOLD}${YELLOW}!!${END} ]${YELLOW}"
QUESTION="[ ${BOLD}${CYAN}??${END} ]${BOLD}"
SUCCESS="[ ${GREEN}OK${END} ]${GREEN}"
DEBUG="[ ${RED}%%${END} ]${BOLD}"
COMMAND="${CYAN}=>  "
FAIL="[${BOLD}${RED}FAIL${END}]${RED}"

INDENT="       "

# log info to the cli
log () {
    # set defaults
    local msg='' log=$1 type=${2:-info} suffix=${3:-'\n'} prefix=$4
    [[ $type = question ]] && suffix=""
    # if type=debug and debug isn't enabled, skip it
    [[ $type = debug ]] && [[ -z $DEBUG_MODE ]] && return 0
    # add log prompt prefix
    if [[ $prefix = false ]]; then
        msg+=""
    elif [[ ! -z $prefix ]]; then
        msg+="${prefix}"
    else
        case "$type" in
            info|important)
                msg+="${INFO} ";;
            question)
                msg+="${QUESTION} ";;
            command)
                msg+="${COMMAND} ";;
            warning)
                msg+="${WARNING} ";;
            success)
                msg+="${SUCCESS} ";;
            fail)
                msg+="${FAIL} ";;
            debug)
                msg+="${DEBUG} ";;
            *)
                msg+="${INFO} ";;
        esac
    fi
    # text styles for the line
    [[ $type = important ]] && msg+="${BOLD}"
    [[ $type = warning ]] && msg+="${BOLD}"
    [[ $type = fail ]] && msg+="${BOLD}"
    # add msg title
    if [[ ! -z $title ]]; then
        msg+="[${title}] "
    fi
    # build log msg
    msg+="${log}${END}${suffix}"
    echo -en "$msg"
}
ask () {
    read -r -p "$(log "$1 " question)" < /dev/tty
}
# ask for a y|n response
yes_no () {
    local msg="$1 ${CYAN}[y|n] "
    read -n 1 -r -p "$(log "$msg" question)" < /dev/tty
    echo ''
    [[ $REPLY = y ]] && return 0 || return 1
    [[ ! $REPLY =~ ^(y|n)$ ]] && log 'Not a valid response' important && yes_no "$@"
}
# continue when ready
continue_when_ready () {
    local msg="${1:-Hit ${CYAN}[enter]${END} to continue.}"
    local value=${2:-''}
    if [[ -z "$2" ]]; then
        read -r -n1 -p "$(log "$msg " question)" user_input
    else
        read -r -p "$(log "$msg " question)" user_input
    fi
    [[ $user_input = "$value" ]] && return 0 || log "Not a valid response." warning && continue_when_ready "$@"
}
# overwrite prompt for when a file exists or action may overwrite other settings
overwrite_handler () {
    local is_task="$2"
    local msg # skip_msg="$3"
    local overwrite backup skip

    # if run_mode is already set, do what is configured
    if [[ "$CONFIG__run_mode" = overwrite ]]; then
        overwrite=true backup=false skip=false
    elif [[ "$CONFIG__run_mode" = backup ]]; then
        overwrite=false backup=true skip=false
    elif [[ "$CONFIG__run_mode" = preserve ]]; then
        overwrite=false backup=false skip=true
    else
        # if is_task, "$1" is the task name, not the file
        if [[ $is_task ]]; then
            task_name="$1"
            msg="${BLUE}${task_name}${END}${BOLD}. What do you want to do?"
        else
            file="$1"
            msg="${MAGENTA}${file}${END} already exists. What do you want to do?"
        fi
        msg+="${END}\n${INDENT}  ${CYAN}[s]${END}kip;\n${INDENT}  ${CYAN}[S]${END}kip all;\n${INDENT}  ${CYAN}[o]${END}verwrite;\n${INDENT}  ${CYAN}[O]${END}verwrite all;\n${INDENT}  ${CYAN}[b]${END}ackup;\n${INDENT}  ${CYAN}[B]${END}ackup all.\n${QUESTION} => "

        log "$msg" question " "
        read -r -e -n 1 REPLY < /dev/tty

        case "$REPLY" in
            o)
                overwrite=true
                ;;
            O)
                overwrite=true
                CONFIG__run_mode=overwrite
                ;;
            b)
                backup=true
                ;;
            B)
                backup=true
                CONFIG__run_mode=backup
                ;;
            s)
                skip=true
                ;;
            S)
                CONFIG__run_mode=preserve
                skip=true
                ;;
            *)
                ;;
        esac
    fi

    if [[ "$overwrite" = true ]]; then
        [[ "$file" ]] && [[ -e "$file" ]] && rm -rf "$file"
    elif [[ "$backup" = true ]]; then
        [[ "$file" ]] && [[ -e "$file" ]] && mv "$file" "${file}.backup"
    elif [[ "$skip" = true ]]; then
        return 1
    fi
}
# throw an error and quit
fail () {
    local msg="$1" should_exit="$2"
    log "$msg" fail
    echo ''
    [[ $should_exit ]] && exit 1
}

# export -f log
# export -f yes_no
# export -f fail
# export -f continue_when_ready