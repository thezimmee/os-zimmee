#!/usr/bin/env bash
#
# simple logging utilities

## colors
BOLD="\033[1m"
NOBOLD="\033[21m"
DIM="\033[2m"
NODIM="\033[22m"
BLACK="\033[30m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"
END="\033[0m"

INFO="[ ${BLUE}..${END} ]"
WARNING="[ ${BOLD}${YELLOW}!!${END} ]${YELLOW}"
QUESTION="[ ${BOLD}${CYAN}??${END} ]${BOLD}"
SUCCESS="[ ${GREEN}OK${END} ]${GREEN}"
DEBUG="[ ${RED}%%${END} ]${BOLD}"
COMMAND="${CYAN}=>  "
FAIL="[${BOLD}${RED}FAIL${END}]${RED}"

INDENT="       "

# log info to the cli
log () {
    # set defaults
    local msg='' log=$1 type=${2:-info} suffix=${3:-'\n'} prefix=$4
    [[ $type = question ]] && suffix=""
    # if type=debug and debug isn't enabled, skip it
    [[ $type = debug ]] && [[ -z $DEBUG_MODE ]] && return 0
    # add log prompt prefix
    if [[ $prefix = false ]]; then
        msg+=""
    elif [[ ! -z $prefix ]]; then
        msg+="${prefix}"
    else
        case "$type" in
            info|important)
                msg+="${INFO} ";;
            question)
                msg+="${QUESTION} ";;
            command)
                msg+="${COMMAND} ";;
            warning)
                msg+="${WARNING} ";;
            success)
                msg+="${SUCCESS} ";;
            fail)
                msg+="${FAIL} ";;
            debug)
                msg+="${DEBUG} ";;
            *)
                msg+="${INFO} ";;
        esac
    fi
    # text styles for the line
    [[ $type = important ]] && msg+="${BOLD}"
    [[ $type = warning ]] && msg+="${BOLD}"
    [[ $type = fail ]] && msg+="${BOLD}"
    # add msg title
    if [[ ! -z $title ]]; then
        msg+="[${title}] "
    fi
    # build log msg
    msg+="${log}${END}${suffix}"
    echo -en "$msg"
}
ask () {
    read -r -p "$(log "$1 " question)" < /dev/tty
}
# ask for a y|n response
yes_no () {
    local msg="$1 ${CYAN}[y|n] "
    read -n 1 -r -p "$(log "$msg" question)" < /dev/tty
    echo ''
    [[ $REPLY = y ]] && return 0 || return 1
    [[ ! $REPLY =~ ^(y|n)$ ]] && log 'Not a valid response' important && yes_no "$@"
}
# continue when ready
continue_when_ready () {
    local msg="${1:-Hit ${CYAN}[enter]${END} to continue.}"
    local value=${2:-''}
    if [[ -z "$2" ]]; then
        read -r -n1 -p "$(log "$msg " question)" user_input
    else
        read -r -p "$(log "$msg " question)" user_input
    fi
    [[ $user_input = "$value" ]] && return 0 || log "Not a valid response." warning && continue_when_ready "$@"
}
# ask about file conflict
ask_file_conflict () {
    local file="$1" msg="$2"
    local overwrite backup skip

    [[ -z "$msg" ]] && msg="${MAGENTA}${file}${END} already exists. What do you want to do?"
    msg+="${END}\n${INDENT}  ${CYAN}[s]${END}kip;\n${INDENT}  ${CYAN}[S]${END}kip all;\n${INDENT}  ${CYAN}[o]${END}verwrite;\n${INDENT}  ${CYAN}[O]${END}verwrite all;\n${INDENT}  ${CYAN}[b]${END}ackup;\n${INDENT}  ${CYAN}[B]${END}ackup all.\n${QUESTION} => "

    log "$msg" question " "
    read -r -e -n 1 REPLY < /dev/tty

    case "$REPLY" in
        o)
            overwrite=true
            ;;
        O)
            overwrite=true
            CONFIG__run_mode=overwrite
            ;;
        b)
            backup=true
            ;;
        B)
            backup=true
            CONFIG__run_mode=backup
            ;;
        s)
            skip=true
            ;;
        S)
            CONFIG__run_mode=preserve
            skip=true
            ;;
        *)
            ;;
    esac

    if [[ "$overwrite" = true ]]; then
        [[ "$file" ]] && [[ -e "$file" ]] rm -rf "$file"
    elif [[ "$backup" = true ]]; then
        [[ "$file" ]] && [[ -e "$file" ]] mv "$file" "${file}.backup"
    elif [[ "$skip" = true ]]; then
        return 1
    fi
}
# file exists prompt
file_exists_handler () {
    local file="$1" msg="$2" # skip_msg="$3"

    if [[ "$CONFIG__run_mode" = overwrite ]]; then
        [[ "$file" != "" ]] && [[ -e "$file" ]] && rm -r "$file"
        return 0
    elif [[ "$CONFIG__run_mode" = backup ]]; then
        [[ "$file" != "" ]] && [[ -e "$file" ]] && mv "$file" "${file}.backup"
        return 0
    elif [[ "$CONFIG__run_mode" = preserve ]]; then
        return 1
    else
        ask_file_conflict "$file" "$msg" && return 0 || return 1
        # yes_no "$yes_no_msg"
        # if [[ "$REPLY" = y ]]; then
        #      [[ "$file" != "" ]] && [[ -e "$file" ]] && rm -r "$file"
        #      return 0
        # fi
        # return 1
    fi
}
# throw an error and quit
fail () {
    local msg="$1" should_exit="$2"
    log "$msg" fail
    echo ''
    [[ $should_exit ]] && exit 1
}

# export -f log
# export -f yes_no
# export -f fail
# export -f continue_when_ready